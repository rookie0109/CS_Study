# 一些记录

sort()函数使用：

```cpp
std::sort(people.begin(), people.end(), [](const Person& p1, const Person& p2) {
        if (p1.age == p2.age) {
            return p1.name < p2.name; // 在年龄相同的情况下，按名字字母顺序排序
        }
        return p1.age < p2.age; // 按年龄排序
    });
```

```bash
g++ -l  + 库名

g++ -L + 库文件
```

constptr修饰的函数，只能有return语句

循环不变式：

斐波那契数列中：` a = fib(i) && b = fib(i+1)`

这个特性从当前状态到下一状态的过程得以保持（对初始状态成立），式子在迭代的每个阶段都成立

循环不变量：一个循环中，每次迭代都保持不变的条件表达式

尾递归：进入下一个函数，不在需要上一个函数的环境，得到的结果直接返回，可以把需要的环境通过参数传递给下一层

非尾递归： 下一个函数结束后，此函数还有后续，需要保存自身环境以供处理返回值

递归需要消耗栈内存空间，C++在编译的时候可以加 -02 优化选项，可以使尾递归占用常量内存空间

```cpp
// lamda 表达式
[将上下文变量以值或者引用的方式捕获，使函数可以使用](参数){内容}；
```

`explicit`: 指定狗在函数或转换函数为显式转换，不能用于隐式转换和复制初始化

```cpp
Class Point{
	int x,y;
    Point(int x = 0, int y = 0): x(x) y(y){}
};
Point p = 1;  // 
```

`std::ref()`:函数中红存在引用单数不能直接传递变量，需要 `ref`包装，一般随 `std::build()`使用;

`std::cref()` : `const`传递

```cpp
viod transfer(Box &from, Box & to, int num){}
std::thread t1(transfer, std::ref(acc1), std::ref(acc2), 10);
```

相关概念：

- **定义definition**：程序中创建一个具体的实体，例如变量、函数或类的实现。在定义中，内存会被分配以存储变量的值、函数的代码或类的成员函数等。**一个实体只能被定义一次，否则会引发重定义错误**。定义一个变量 `int x = 10`，函数,类等
- **声明declaration**:声明是在程序中引入一个标识符（例如变量名、函数名、类名等），以告诉编译器它的存在和类型，但不会分配内存或提供实现。一个标识符可以被多次声明（在不同的作用域下)，但只能被定义一次。多次声明会报错
- **实例化Instantiation**:实例化是将模板代码转换成具体的类型或函数的过程。在 C++ 中，有类模板和函数模板，当使用类模板或函数模板时，编译器会根据使用的类型或函数参数自动实例化出具体的类或函数。

在 C++ 中，声明一个类不会立即占用内存。类的声明只是告诉编译器该类的存在和成员的类型，但并没有分配内存空间或实例化对象。只有当你**创建类的实例（对象）**时，才会分配内存空间来存储对象的成员变量和函数。

类的声明通常在头文件（.h 或 .hpp 文件）中完成，而类的定义（包含成员函数和成员变量的实现）通常在源文件（.cpp 文件）中完成。在头文件中，你可以声明类的名称、成员函数、成员变量等，而在源文件中，你可以提供类的具体实现。

### static
**类的静态成员：**静态成员变量是属于**类本身**的变量，而不是属于类的任何特定对象的变量。它们存储在类的静态存储区域中。静态成员变量必须在类的定义外部进行初始化，通常在类的实现文件（.cpp）中进行初始化。
**静态成员函数：**
静态成员函数不依赖于特定对象的状态，因此它们不可以访问非静态成员变量或调用非静态成员函数。静态成员函数通常用于执行与类相关的操作，而不需要访问类的实例数据。
可以通过`class::static_value`访问

### pragma
`#pragma once` 是一种预处理指令，用于确保头文件（.h 或 .hpp 文件）只被编译一次，即使它被包含多次。这是为了防止头文件的多重包含，以避免出现编译错误和重复的符号定义。

```cpp
std::make_pair 创建 std::pair对象

std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9};

// 使用 remove_if 移除偶数
// remove_if 需要包含头文件algorithm
numbers.erase(std::remove_if(numbers.begin(), numbers.end(), [](int x) { return x % 2 == 0; }), numbers.end());


// lambda表达式




// find
std::vector<int> vec1;
std::set<int> set2;
vectir<int>::iterator it = std::find(vec1.begin(), vec1.end(), target);
set2.find(target);

```

### string
```cpp
int stoi(string str， size_t pose);  // 将字符串转换为整数
string substr(size_t _off, size_t len);   // 获取子字符串，off_起始位置， len 子字符串长度，如果不设置，直接到结束
istringstream name(string input);  // 构建字符串流
```

### map
`std::map<key, value>`

### lambda
一般形式`[] () {return ;}`，其中`[]`,表示不使用其他变量， `[&]` 按引用使用其他变量， `[=]` 按值使用其他变量，[this] 使用类的指针


在类内都能使用this指针，通常，this 指针用于区分对象的成员变量和同名的局部变量之间的冲突。

### 文件读取

```cpp
// 常见操作
ifstream  fin；      // 写文件
ofstream fout;      // 读文件
打开文件 fin.open ("文件路径" ,打开方式)
打开方式包括：
ios::in 读文件
ios::out 写文件（直接用的话会丢丢弃已有数据，即隐含为trunc）
ios::binary 二进制方式
ios:app 追加写（要配合out使用，直接写的话会隐含用ios：：out
ios::trunc 覆盖写（要配合out使用）
ios::out|ios::binary 二进制写


FILE* boundary_file = fopen(boundary_file_dir.c_str(), "r");
// c_str() 将string字符串转换为c风格的字符串(以null结尾)
// stream：这是一个指向文件的指针，从中读取数据。
// format：这是一个格式字符串，指定了要读取的数据的类型和格式
int fscanf(FILE *stream, const char *format, ...);
// 使用fscanf会移动文件指针到特定一行

```