# 一些记录

sort()函数使用：

```cpp
std::sort(people.begin(), people.end(), [](const Person& p1, const Person& p2) {
        if (p1.age == p2.age) {
            return p1.name < p2.name; // 在年龄相同的情况下，按名字字母顺序排序
        }
        return p1.age < p2.age; // 按年龄排序
    });
```

```bash
g++ -l  + 库名

g++ -L + 库文件
```

constptr修饰的函数，只能有return语句

循环不变式：

斐波那契数列中：` a = fib(i) && b = fib(i+1)`

这个特性从当前状态到下一状态的过程得以保持（对初始状态成立），式子在迭代的每个阶段都成立

循环不变量：一个循环中，每次迭代都保持不变的条件表达式

尾递归：进入下一个函数，不在需要上一个函数的环境，得到的结果直接返回，可以把需要的环境通过参数传递给下一层

非尾递归： 下一个函数结束后，此函数还有后续，需要保存自身环境以供处理返回值

递归需要消耗栈内存空间，C++在编译的时候可以加 -02 优化选项，可以使尾递归占用常量内存空间

```cpp
// lamda 表达式
[将上下文变量以值或者引用的方式捕获，使函数可以使用](参数){内容}；
```

`explicit`: 指定狗在函数或转换函数为显式转换，不能用于隐式转换和复制初始化

```cpp
Class Point{
	int x,y;
    Point(int x = 0, int y = 0): x(x) y(y){}
};
Point p = 1;  // 
```

`std::ref()`:函数中红存在引用单数不能直接传递变量，需要`ref`包装，一般随`std::build()`使用;

`std::cref()` : `const`传递

```cpp
viod transfer(Box &from, Box & to, int num){}
std::thread t1(transfer, std::ref(acc1), std::ref(acc2), 10);
```











