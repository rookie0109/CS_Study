# 一些记录

sort()函数使用：

```cpp
std::sort(people.begin(), people.end(), [](const Person& p1, const Person& p2) {
        if (p1.age == p2.age) {
            return p1.name < p2.name; // 在年龄相同的情况下，按名字字母顺序排序
        }
        return p1.age < p2.age; // 按年龄排序
    });
```

```bash
g++ -l  + 库名

g++ -L + 库文件
```

constptr修饰的函数，只能有return语句

循环不变式：

斐波那契数列中：` a = fib(i) && b = fib(i+1)`

这个特性从当前状态到下一状态的过程得以保持（对初始状态成立），式子在迭代的每个阶段都成立

循环不变量：一个循环中，每次迭代都保持不变的条件表达式

尾递归：进入下一个函数，不在需要上一个函数的环境，得到的结果直接返回，可以把需要的环境通过参数传递给下一层

非尾递归： 下一个函数结束后，此函数还有后续，需要保存自身环境以供处理返回值

递归需要消耗栈内存空间，C++在编译的时候可以加 -02 优化选项，可以使尾递归占用常量内存空间

```cpp
// lamda 表达式
[将上下文变量以值或者引用的方式捕获，使函数可以使用](参数){内容}；
```

`explicit`: 指定狗在函数或转换函数为显式转换，不能用于隐式转换和复制初始化

```cpp
Class Point{
	int x,y;
    Point(int x = 0, int y = 0): x(x) y(y){}
};
Point p = 1;  // 
```

`std::ref()`:函数中红存在引用单数不能直接传递变量，需要 `ref`包装，一般随 `std::build()`使用;

`std::cref()` : `const`传递

```cpp
viod transfer(Box &from, Box & to, int num){}
std::thread t1(transfer, std::ref(acc1), std::ref(acc2), 10);
```

相关概念：

- **定义definition**：程序中创建一个具体的实体，例如变量、函数或类的实现。在定义中，内存会被分配以存储变量的值、函数的代码或类的成员函数等。**一个实体只能被定义一次，否则会引发重定义错误**。定义一个变量 `int x = 10`，函数,类等
- **声明declaration**:声明是在程序中引入一个标识符（例如变量名、函数名、类名等），以告诉编译器它的存在和类型，但不会分配内存或提供实现。一个标识符可以被多次声明（在不同的作用域下)，但只能被定义一次。多次声明会报错
- **实例化Instantiation**:实例化是将模板代码转换成具体的类型或函数的过程。在 C++ 中，有类模板和函数模板，当使用类模板或函数模板时，编译器会根据使用的类型或函数参数自动实例化出具体的类或函数。

在 C++ 中，声明一个类不会立即占用内存。类的声明只是告诉编译器该类的存在和成员的类型，但并没有分配内存空间或实例化对象。只有当你**创建类的实例（对象）**时，才会分配内存空间来存储对象的成员变量和函数。

类的声明通常在头文件（.h 或 .hpp 文件）中完成，而类的定义（包含成员函数和成员变量的实现）通常在源文件（.cpp 文件）中完成。在头文件中，你可以声明类的名称、成员函数、成员变量等，而在源文件中，你可以提供类的具体实现。
