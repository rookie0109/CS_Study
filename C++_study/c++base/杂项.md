# 一些记录

sort()函数使用：

```cpp
std::sort(people.begin(), people.end(), [](const Person& p1, const Person& p2) {
        if (p1.age == p2.age) {
            return p1.name < p2.name; // 在年龄相同的情况下，按名字字母顺序排序
        }
        return p1.age < p2.age; // 按年龄排序
    });
```

```bash
g++ -l  + 库名

g++ -L + 库文件
```

constptr修饰的函数，只能有return语句

循环不变式：

斐波那契数列中：` a = fib(i) && b = fib(i+1)`

这个特性从当前状态到下一状态的过程得以保持（对初始状态成立），式子在迭代的每个阶段都成立

循环不变量：一个循环中，每次迭代都保持不变的条件表达式

尾递归：进入下一个函数，不在需要上一个函数的环境，得到的结果直接返回，可以把需要的环境通过参数传递给下一层

非尾递归： 下一个函数结束后，此函数还有后续，需要保存自身环境以供处理返回值

递归需要消耗栈内存空间，C++在编译的时候可以加 -02 优化选项，可以使尾递归占用常量内存空间

```cpp
// lamda 表达式
[将上下文变量以值或者引用的方式捕获，使函数可以使用](参数){内容}；
```

`explicit`: 指定狗在函数或转换函数为显式转换，不能用于隐式转换和复制初始化

```cpp
Class Point{
	int x,y;
    Point(int x = 0, int y = 0): x(x) y(y){}
};
Point p = 1;  // 
```

`std::ref()`:函数中红存在引用单数不能直接传递变量，需要 `ref`包装，一般随 `std::build()`使用;

`std::cref()` : `const`传递

```cpp
viod transfer(Box &from, Box & to, int num){}
std::thread t1(transfer, std::ref(acc1), std::ref(acc2), 10);
```

相关概念：

- **定义definition**：程序中创建一个具体的实体，例如变量、函数或类的实现。在定义中，内存会被分配以存储变量的值、函数的代码或类的成员函数等。**一个实体只能被定义一次，否则会引发重定义错误**。定义一个变量 `int x = 10`，函数,类等
- **声明declaration**:声明是在程序中引入一个标识符（例如变量名、函数名、类名等），以告诉编译器它的存在和类型，但不会分配内存或提供实现。一个标识符可以被多次声明（在不同的作用域下)，但只能被定义一次。多次声明会报错
- **实例化Instantiation**:实例化是将模板代码转换成具体的类型或函数的过程。在 C++ 中，有类模板和函数模板，当使用类模板或函数模板时，编译器会根据使用的类型或函数参数自动实例化出具体的类或函数。

在 C++ 中，声明一个类不会立即占用内存。类的声明只是告诉编译器该类的存在和成员的类型，但并没有分配内存空间或实例化对象。只有当你**创建类的实例（对象）**时，才会分配内存空间来存储对象的成员变量和函数。

类的声明通常在头文件（.h 或 .hpp 文件）中完成，而类的定义（包含成员函数和成员变量的实现）通常在源文件（.cpp 文件）中完成。在头文件中，你可以声明类的名称、成员函数、成员变量等，而在源文件中，你可以提供类的具体实现。

### static
**类的静态成员：**静态成员变量是属于**类本身**的变量，而不是属于类的任何特定对象的变量。它们存储在类的静态存储区域中。静态成员变量必须在类的定义外部进行初始化，通常在类的实现文件（.cpp）中进行初始化。
**静态成员函数：**
静态成员函数不依赖于特定对象的状态，因此它们不可以访问非静态成员变量或调用非静态成员函数。静态成员函数通常用于执行与类相关的操作，而不需要访问类的实例数据。
可以通过`class::static_value`访问

**c/c++共有**

​      1）：修饰**全局变量**时，表明一个全局变量只对定义在同一文件中的函数可见。             

​      2）：修饰**局部变量**时，表明该变量的值不会因为函数终止而丢失。       

​      3）：修饰**函数**时，表明该函数只在同一文件中调用。

**c++独有：**

​      4）：修饰**类的数据成员**，表明对该类所有对象这个数据成员都只有一个实例。即该实例归 所有对象共有。

​      5）：用static修饰不访问非静态数据成员的**类成员函数**。这意味着一个静态成员函数只能访问它的参数、类的静态数据成员和全局变量

### pragma
`#pragma once` 是一种预处理指令，用于确保头文件（.h 或 .hpp 文件）只被编译一次，即使它被包含多次。这是为了防止头文件的多重包含，以避免出现编译错误和重复的符号定义。

```cpp
std::make_pair 创建 std::pair对象

std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9};

// 使用 remove_if 移除偶数
// remove_if 需要包含头文件algorithm
numbers.erase(std::remove_if(numbers.begin(), numbers.end(), [](int x) { return x % 2 == 0; }), numbers.end());


// lambda表达式




// find
std::vector<int> vec1;
std::set<int> set2;
vectir<int>::iterator it = std::find(vec1.begin(), vec1.end(), target);
set2.find(target);

```

### string
```cpp
int stoi(string str， size_t pose);  // 将字符串转换为整数
string substr(size_t _off, size_t len);   // 获取子字符串，off_起始位置， len 子字符串长度，如果不设置，直接到结束
istringstream name(string input);  // 构建字符串流
```

### map
`std::map<key, value>`

### lambda
一般形式`[] () {return ;}`，其中`[]`,表示不使用其他变量， `[&]` 按引用使用其他变量， `[=]` 按值使用其他变量，[this] 使用类的指针


在类内都能使用this指针，通常，this 指针用于区分对象的成员变量和同名的局部变量之间的冲突。

### 文件读取

```cpp
// 常见操作
ifstream  fin；      // 写文件
ofstream fout;      // 读文件
打开文件 fin.open ("文件路径" ,打开方式)
打开方式包括：
ios::in 读文件
ios::out 写文件（直接用的话会丢丢弃已有数据，即隐含为trunc）
ios::binary 二进制方式
ios:app 追加写（要配合out使用，直接写的话会隐含用ios：：out
ios::trunc 覆盖写（要配合out使用）
ios::out|ios::binary 二进制写


FILE* boundary_file = fopen(boundary_file_dir.c_str(), "r");
// c_str() 将string字符串转换为c风格的字符串(以null结尾)
// stream：这是一个指向文件的指针，从中读取数据。
// format：这是一个格式字符串，指定了要读取的数据的类型和格式
int fscanf(FILE *stream, const char *format, ...);
// 使用fscanf会移动文件指针到特定一行

```

### 虚函数

- 构造函数的目的是初始化对象的状态。在对象的构造过程中，对象的虚函数表可能尚未完全建立。因此，在构造函数中调用虚函数可能导致不可预测的行为。通常，虚函数表的构建发生在构造函数之前，因此虚函数在构造函数中不起作用。因此，C++不允许构造函数是虚函数。

为什么析构函数可以为虚函数？

- 析构函数的目的是在对象生命周期结束时清理对象状态。由于对象的虚函数表在析构函数执行之前仍然有效，因此可以使用虚函数来实现多态的析构行为。这对于处理继承关系中的资源管理非常有用，因为派生类可能会分配额外的资源。通过使用虚析构函数，确保在删除指向派生类对象的基类指针时，析构函数的正确版本会被调用，从而释放派生类对象的资源。这是C++中实现多态析构的常见用法。

### 运算符优先级

逻辑运算符 NOT !

算术运算符 * / %

算数运算符 + -

关系运算符  < > <= >=

关系运算符 == !=

逻辑运算符 and &&

逻辑运算符 or ||

赋值运算符

### switch

switch(表达式)，表达式只能是整数类型，字符类型和枚举类型，并且case : 之后的break;需要加上，**当某一个标签符合表达式时，后续所有语句都会执行**，所以加上break直接跳转到结尾。

### vector

vector可以通过数组进行初始化

```cpp
int ele_vals[18] = {1, 2, ..., };
std::vector ele(ele_als, ele_vals + 18);
```

`int *pi = 0;// 初始化一个空指针`

## 抽象基类

至少包含一个纯虚函数`virtual viod function() = 0;`,抽象基类只能作为基类，不能实例化

### 杂项

```cpp
// 查找某一个类型的边界
#include <limits>
int min_int = std::numeric_limits<int>::min();
```

当调用函数时，内存中建立一块特殊区域"程序堆栈"，这块区域提供每个函数参数的存储空间。也提供了函数所定义的每一个对象的内存空间（局部对象），一旦函数完成，此块内存就会被释放

`const int &A` 和 `int const &A` 都表示相同的含义，它们都是指向整数常量的引用。

```cpp
// 引用指向的地址不变，引用是在编译器层面的指针     
int a = 30;
int c = 60;
int &b = a;
b = c;
std::cout << "a:" << a << std::endl;	// 60
std::cout << "b:" << b << std::endl;
```

[const相关](https://blog.csdn.net/zhangheng837964767/article/details/33783511)

## 面试

C++ 多态

编译时多态性（静态多态）：通过重载函数实现：先期联编 early binding
运行时多态性（动态多态）：通过虚函数实现 ：滞后联编 late binding

C++ 中的隐藏

如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual 关键字，基类的函数将被隐藏（注意别与重载混淆，重载是在同一个类中发生）。

如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆，覆盖有virtual关键字）。

C++ 内联函数

使用代码块代替函数，减少函数调用开销